---
inclusion: always
---

# 网络同步和模组开发指南

## 网络同步架构

### 主机-客户端模式
- **主机 (Host)**: 拥有游戏状态的权威性，负责AI逻辑和物理计算
- **客户端 (Client)**: 接收并应用主机的状态更新，发送本地玩家输入
- **同步原则**: 主机决定，客户端表现

### 数据同步策略
- **关键数据**: 使用可靠传输 (`ReliableOrdered`)
  - 玩家连接/断开
  - 物品拾取/丢弃
  - 血量变化
  - 场景切换
- **频繁数据**: 使用不可靠传输 (`Unreliable`)
  - 玩家位置和旋转
  - 动画状态
  - 武器瞄准方向

### 网络对象管理
- 使用 `NetTag` 系统标记需要同步的游戏对象
- 为每个网络对象分配唯一ID
- 实现对象的创建、更新、销毁同步
- 处理网络对象的所有权转移

## 游戏状态同步

### 玩家状态同步
```csharp
// 玩家状态数据结构
public class PlayerStatus
{
    public string EndPoint;           // 玩家唯一标识
    public string PlayerName;         // 玩家名称
    public Vector3 Position;          // 位置
    public Quaternion Rotation;       // 旋转
    public bool IsInGame;            // 是否在游戏中
    public float Health;             // 血量
    public string CustomFaceJson;    // 自定义外观
}
```

### AI同步机制
- 只有主机运行AI逻辑 (`COOPManager.AIHandle.freezeAI`)
- 客户端接收AI状态更新并应用
- 同步AI的位置、动画、血量、行为状态
- 处理AI的生成和销毁

### 物品和装备同步
- 同步玩家装备的穿戴和卸下
- 同步武器的切换和使用
- 同步战利品箱的开启和物品分配
- 处理物品的拾取冲突

## 性能优化

### 网络带宽优化
- 使用增量更新减少数据传输量
- 压缩重复的网络数据
- 根据距离调整同步频率
- 批量发送多个小数据包

### 内存优化
- 及时清理断开连接的玩家对象
- 使用对象池管理网络消息
- 避免在网络回调中创建大量临时对象
- 定期执行垃圾回收

### CPU优化
- 避免在每帧都进行网络操作
- 使用定时器控制同步频率
- 缓存频繁访问的网络数据
- 异步处理耗时的网络操作

## 错误处理和容错

### 网络异常处理
- 处理连接超时和断开
- 实现自动重连机制
- 验证网络数据的完整性
- 处理数据包丢失和乱序

### 游戏状态一致性
- 检测和修复状态不同步
- 实现状态回滚机制
- 处理玩家中途加入游戏
- 同步场景切换状态

### 调试和监控
- 记录网络延迟和丢包率
- 监控同步数据的准确性
- 提供网络状态的可视化界面
- 实现网络问题的自动诊断

## 模组兼容性

### Harmony补丁最佳实践
- 使用前缀和后缀补丁而非替换
- 检查其他模组的兼容性
- 提供补丁的开关机制
- 记录补丁的应用状态

### 游戏版本兼容
- 检测游戏版本并适配
- 处理游戏更新导致的API变化
- 提供向后兼容的接口
- 及时更新模组以支持新版本

### 第三方依赖管理
- 明确标注依赖的库版本
- 处理依赖库的版本冲突
- 提供依赖库的自动下载
- 测试不同依赖版本的兼容性

## 安全考虑

### 网络安全
- 验证网络消息的来源
- 防止恶意数据包攻击
- 限制网络消息的频率
- 加密敏感的网络数据

### 游戏平衡
- 防止客户端作弊
- 验证玩家操作的合法性
- 限制异常的游戏行为
- 记录可疑的玩家活动

## 测试策略

### 网络测试
- 测试不同网络条件下的表现
- 模拟高延迟和丢包环境
- 测试多人同时连接的稳定性
- 验证断线重连的可靠性

### 兼容性测试
- 测试与其他模组的兼容性
- 验证不同游戏版本的支持
- 测试不同操作系统的兼容性
- 检查内存泄漏和性能问题